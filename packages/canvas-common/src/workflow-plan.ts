import { z } from 'zod/v3';
import { RawCanvasData } from '@refly/openapi-schema';
import { genNodeEntityId, genNodeID, genUniqueId } from '@refly/utils';

export const workflowPlanSchema = z.object({
  tasks: z
    .array(
      z.object({
        id: z.string().describe('Unique identifier for the task'),
        title: z.string().describe('Display title of the task'),
        prompt: z.string().describe('The prompt or instruction for this task'),
        products: z
          .array(
            z.object({
              id: z.string().describe('Unique identifier for the product'),
              type: z
                .enum(['document', 'codeArtifact', 'image', 'video', 'audio'])
                .describe('Type of the product'),
              title: z.string().describe('Display title of the product'),
            }),
          )
          .optional()
          .describe('Products expected to be generated by this task'),
        contextItems: z
          .array(
            z.object({
              id: z.string().describe('Unique identifier for the context item'),
              type: z.enum(['product', 'task']).describe('Type of the context item'),
            }),
          )
          .optional()
          .describe('Context items expected to be used by this task'),
        selectedToolsets: z
          .array(
            z.object({
              key: z.string().describe('Key identifier for the toolset'),
              tools: z.array(z.string()).describe('Array of tool names in this toolset'),
            }),
          )
          .describe('Toolsets selected for this task'),
      }),
    )
    .describe('Array of workflow tasks to be executed'),
  variables: z
    .array(
      z.object({
        name: z.string().describe('Variable name used in the workflow'),
        type: z.string().describe('Data type of the variable (e.g., string, number, boolean)'),
        description: z.string().describe('Description of what this variable represents'),
      }),
    )
    .describe('Array of variables defined for the workflow'),
});

// Generate canvas data from workflow plan
// 1. each task should be represented as a 'skillResponse' node
// 2. each product should be represented as a product node with type being the product type
// 3. connect task nodes to parent nodes according to its contextItems definition
// 4. connect product nodes to parent task nodes according to parent task's products definition
export const generateCanvasDataFromWorkflowPlan = (
  workflowPlan: z.infer<typeof workflowPlanSchema>,
): RawCanvasData => {
  const nodes: RawCanvasData['nodes'] = [];
  const edges: RawCanvasData['edges'] = [];

  // Maps to resolve context references
  const taskIdToNodeId = new Map<string, string>();
  const productIdToNodeId = new Map<string, string>();
  const taskIdToEntityId = new Map<string, string>();

  // Simple layout positions
  const taskStartX = 0;
  const productOffsetX = 480;
  const rowStepY = 240;
  const productStepY = 180;

  if (Array.isArray(workflowPlan.tasks)) {
    workflowPlan.tasks.forEach((task, taskIndex) => {
      const taskId = task?.id ?? `task-${taskIndex}`;
      const taskTitle = task?.title ?? '';
      const taskPrompt = task?.prompt ?? '';

      // Build selected toolsets metadata from plan
      const selectedToolsetsSource = Array.isArray(task.selectedToolsets)
        ? task.selectedToolsets
        : [];
      const selectedToolsets = selectedToolsetsSource
        .filter((t) => Boolean(t?.key))
        .map((t) => ({
          type: 'regular',
          id: String(t?.key),
          name: String(t?.key),
          selectedTools: (Array.isArray(t?.tools) ? t?.tools : []) as string[],
        }));

      // Create task node (skillResponse)
      const taskNodeId = genNodeID();
      const taskEntityId = genNodeEntityId('skillResponse');
      const taskNode = {
        id: taskNodeId,
        type: 'skillResponse' as const,
        position: { x: taskStartX, y: taskIndex * rowStepY },
        data: {
          title: taskTitle,
          entityId: taskEntityId,
          contentPreview: '',
          metadata: {
            structuredData: { query: taskPrompt },
            selectedToolsets,
            contextItems: Array.isArray(task.contextItems) ? task.contextItems : [],
          },
        },
      };

      nodes.push(taskNode);
      taskIdToNodeId.set(taskId, taskNodeId);
      taskIdToEntityId.set(taskId, taskEntityId);

      // Create edges from context items to this task
      if (Array.isArray(task.contextItems)) {
        for (const ctx of task.contextItems) {
          const ctxType = ctx?.type ?? '';
          const ctxId = ctx?.id ?? '';
          let sourceNodeId: string | undefined;

          if (ctxType === 'task') {
            sourceNodeId = taskIdToNodeId.get(ctxId);
          } else if (ctxType === 'product') {
            sourceNodeId = productIdToNodeId.get(ctxId);
          }

          if (sourceNodeId) {
            edges.push({
              id: `edge-${genUniqueId()}`,
              source: sourceNodeId,
              target: taskNodeId,
              type: 'default',
            });
          }
        }
      }

      // Create product nodes and connect from task node
      if (Array.isArray(task.products) && task.products.length > 0) {
        task.products.forEach((product, pIndex) => {
          const productId = product?.id ?? `${taskId}-product-${pIndex}`;
          const productType = product?.type ?? 'document';
          const productTitle = product?.title ?? '';

          const productNodeId = genNodeID();
          const productEntityId = genNodeEntityId(productType as any);
          const productNode = {
            id: productNodeId,
            type: productType as any,
            position: {
              x: productOffsetX,
              y: taskIndex * rowStepY + pIndex * productStepY,
            },
            data: {
              title: productTitle,
              entityId: productEntityId,
              contentPreview: '',
              metadata: {
                parentResultId: taskEntityId,
                contextItems: [],
              },
            },
          };

          nodes.push(productNode);
          productIdToNodeId.set(productId, productNodeId);

          edges.push({
            id: `edge-${genUniqueId()}`,
            source: taskNodeId,
            target: productNodeId,
            type: 'default',
          });
        });
      }
    });
  }

  return { nodes, edges };
};
